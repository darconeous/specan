/*
 * Copyright 2010 Michael Ossmann
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * There is one channel per column of the display.  The radio is tuned to one
 * channel at a time and RSSI is displayed for that channel.
 */
#define NUM_CHANNELS 132

/*
 * wide mode (default): 44 MHz on screen, 333 kHz per channel
 * narrow mode: 6.6 MHz on screen, 50 kHz per channel
 */
#define WIDE 0
#define NARROW 1
#define ULTRAWIDE 2
#define VERYNARROW 3

/*
 * Normal IM-ME devices have a 26 MHz crystal, but
 * some of them are shipping with 27 MHz crystals.
 * Use this preprocessor macro to compensate if your
 * IMME is so afflicted. See this link for more info:
 * <http://madscientistlabs.blogspot.com/2011/03/fix-for-im-me-specan-frequency-offset.html>
 */
#ifndef FREQ_REF
#define FREQ_REF	(26000000)
#endif

/*
 * short mode (default): displays RSSI >> 2
 * tall mode: displays RSSI
 */
#define SHORT 0
#define TALL 1

/* vertical scrolling */
#define SHORT_STEP  16
#define TALL_STEP   4
#define MAX_VSCROLL 208
#define MIN_VSCROLL 0

/* frequencies in MHz */
#define DEFAULT_FREQ     915
#define WIDE_STEP        5
#define NARROW_STEP      1
#define ULTRAWIDE_STEP   10
#define VERYNARROW_STEP  1
#define WIDE_MARGIN      13
#define NARROW_MARGIN    3
#define ULTRAWIDE_MARGIN 42
#define VERYNARROW_MARGIN 3

/* frequency bands supported by device */
#define BAND_300 0
#define BAND_400 1
#define BAND_900 2

/* band limits in MHz */
#define MIN_300  281
#define MAX_300  361
#define MIN_400  378
#define MAX_400  481
#define MIN_900  749
#define MAX_900  962

/* band transition points in MHz */
#define EDGE_400 369
#define EDGE_900 615

/* VCO transition points in Hz */
#define MID_300  318000000
#define MID_400  424000000
#define MID_900  848000000

/*
 * The original channel spacing values were
 * all uniformally scaled by 0.99976 from the
 * values described in the readme. I've pulled
 * it out here for experimentation purposes.
 */
#ifndef SPACING_FUDGE
#define SPACING_FUDGE		(1.0)
#endif

/* channel spacing in Hz */
#define VERYNARROW_SPACING	(u32)(25000*SPACING_FUDGE)	// 25kHz
#define NARROW_SPACING		(u32)(50000*SPACING_FUDGE)	// 50kHz
#define WIDE_SPACING		(u32)(200000*SPACING_FUDGE)	// 200kHz
#define ULTRAWIDE_SPACING	(u32)(666667*SPACING_FUDGE)	// 667kHz

#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))

/* bitmaps */
static const u8 narrow_ruler[] = {
	0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02
};

static const u8 wide_ruler[] = {
	0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0x3E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0x3E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E,
	/* extra to accommodate offset starting point */
	0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0x3E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E
};

static const u8 ultrawide_ruler[] = {
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02
};

/* A randomly ordered list of numbers from 0 to 131. */
static const u8 update_order[132] = {
	108, 58, 9, 51, 79, 37, 23, 96,
	99, 19, 88, 33, 26, 40, 81, 85,
	110, 80, 111, 114, 68, 86, 95, 82,
	0, 62, 43, 36, 39, 38, 5, 28,
	27, 74, 97, 67, 72, 10, 118, 92,
	4, 121, 98, 8, 53, 16, 75, 17,
	54, 73, 83, 101, 47, 105, 119, 41,
	55, 13, 14, 35, 1, 77, 49, 116,
	24, 125, 122, 25, 107, 22, 78, 59,
	20, 112, 103, 100, 106, 91, 52, 131,
	12, 50, 63, 7, 31, 21, 32, 65,
	124, 93, 29, 130, 115, 60, 34, 15,
	69, 66, 44, 113, 127, 11, 120, 76,
	89, 64, 56, 6, 87, 126, 48, 102,
	109, 70, 61, 42, 46, 123, 45, 84,
	57, 3, 129, 30, 117, 71, 128, 104,
	94, 2, 18, 90, 
};

/* Keeping track of all this for each channel allows us to tune faster. */
typedef struct {
	/* frequency setting */
	u8 freq2;
	u8 freq1;
	u8 freq0;
	
	/* frequency calibration */
	u8 fscal3;
	u8 fscal2;
	u8 fscal1;

	/* signal strength */
	u8 ss;
	u8 max;
} channel_info;

void clear();
void plot(u8 col);
void putchar(char c);
u8 getkey();
void draw_ruler();
void draw_freq();
void radio_setup();
void set_filter();
void set_radio_freq(u32 freq);
void calibrate_freq(u32 freq, u8 ch);
u16 set_center_freq(u16 freq);
void tune(u8 ch);
void set_width(u8 w);
void poll_keyboard();
void main(void);
